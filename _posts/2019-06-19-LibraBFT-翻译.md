---
layout: post
title: LibraBFT中文翻译
tags: 
- 共识协议
- LibraBFT
categories: 区块链
---
* TOC
{:toc}

摘要。 本报告介绍了LibraBFT，这是一个针对Libra Blockchain设计的强大而高效的状态机复制系统。 LibraBFT基于HotStuff，这是最近的一项协议，利用拜占庭容错（BFT）数十年的科学进步，实现了互联网设置所需的强大的可扩展性和安全性。 LibraBFT进一步完善了HotStuff协议，引入了明确的活跃度机制，并提供了具体的延迟分析。 为了推动与Libra Blockchain的集成，本文档提供了从全功能模拟器中提取的规范。 这些规范包括状态复制接口和用于参与者之间的数据传输和状态同步的通信框架。 最后，本报告提供了一个正式的安全证明，它引出了检测BFT节点不良行为的标准，同时还有一个简单的奖励和惩罚机制。

# 1 介绍

互联网和移动宽带的出现使全球数十亿人接触，提供知识，免费通信和各种低成本，更便捷的服务。 这种连接还使更多人能够访问金融生态系统。 然而，尽管取得了这些进展，但对于那些最需要金融服务的人来说，获得金融服务仍然有限。

区块链和加密货币表明，计算机科学，密码学和经济学的最新进展有可能在金融基础设施方面创造创新，但现有系统尚未达到主流应用。 作为实现这一目标的下一步，我们设计了Libra Blockchain [1]，[2]，目的是建立一个简单的全球货币和金融基础设施，为数十亿人提供支持。

这个新区块链的核心是一个名为LibraBFT的共识协议 - 本报告的重点 - 通过该协议对区块链交易进行排序和最终确定。 LibraBFT在参与共识协议的一组验证器中分散信任。 LibraBFT保证就诚实验证者之间的交易历史达成共识，即使参与者的门槛是拜占庭（即有缺陷或腐败[3]），它仍然是安全的。 通过采用经典的拜占庭容错方法，LibraBFT建立在分布式计算中坚实且经过严格验证的基础之上。 此外，科学界已经在LibraBFT的基础上取得了稳步进展，在扩展共识技术方面，并使其在互联网环境中保持稳健。

最初，参与的验证者将被允许进入共识网络，该协会由地理上分布的和不同的创始成员组成，这些成员是根据客观成员标准选择的组织，具有引导Libra生态系统的既得利益[2]。 随着时间的推移，会员资格将变为开放，仅基于组织持有Libra[4]。

LibraBFT的共识基于一种名为HotStuff的前沿技术[5]，[6]，它在BFT共识和区块链的世界之间架起了桥梁。 这种选择反映了丰富的专业知识和各种替代方案的探索，并为LibraBFT提供了以下关键属性，这些属性对于分散信任至关重要：

<!--more-->  

- **安全性：** LibraBFT保持诚实验证者之间的一致性，即使多达三分之一的验证者作恶。

- **异步：** 即使在网络异步的情况下（即，在无限制的通信延迟或网络中断期间），也保证一致性。 这反映了我们的信念，即构建互联网规模的共识协议，其安全性依赖于同步，本质上既复杂又容易受到网络上的拒绝服务（DoS）攻击。

- **不可改变性：** LibraBFT支持不可改变性概念，即交易变得不可逆转。 它提供了简明的承诺，用于向最终用户验证分类帐查询的结果。

- **线性和响应性：** LibraBFT有两个理想的属性，HotStuff之前的BFT共识协议无法同时支持 - 线性和响应性。 这两个技术概念与领导者的概念相关联，这是推动部分同步进展的关键方法。 非正式地，线性保证即使领导者轮换，推动交易提交也只会产生线性通信（这是最优的）; 响应性意味着领导者在收集来自验证者的响应时没有内置的延迟步骤和进展。

- **简单性和模块性：** LibraBFT的核心逻辑允许简单而强大的实现，与基于Nakamoto共识的公共区块链相似[7]。 值得注意的是，该协议围绕单个通信阶段进行组织，并允许简明的安全性参数。

- **可持续性：** 据报道，信任基于计算能力的当前公共区块链消耗大量能量[8]，可能需要集中化[9]。 LibraBFT被设计为股权证明系统，其中参与特权基于其财务参与被授予已知成员。 LibraBFT可以支持经济激励措施，以奖励良好行为和/或惩罚利益相关者的错误行为。 LibraBFT中的计算成本主要包括加密签名，这是一种具有高效实现的标准概念。

**关键技术方法** LibraBFT是一个共识协议，在轮次中进行，在每轮中，在验证者中选择领导者。 如上所述，需要这种关键方法来推动部分同步的进展。 领导者提出一个由事务组成的新块，并将其发送给其他验证者，如果新块都是由有效事务组成，则验证者验证新块。一旦领导者收集了大多数选票，她就会将其发送给其他验证人。如果领导者未能提出有效的区块或者没有聚集足够的选票，则超时机制将强制进行新一轮，并且将从验证器中选择新的领导者。 这样，新块扩展了区块链。 最终，一个块将满足LibraBFT的提交规则，一旦发生这种情况，就会提交此块和任何先前的块。

**相关工作** 全面的调查超出了本手稿的范围（例如参见[10]  -  [12]）。 在这里，我们提到影响我们工作的关键概念和机制。 经典设置中的共识算法。 拜占庭共识问题由Lamport等人开创。 [3]，他还创造了拜占庭一词来模拟任意的，可能是恶意腐败的行为。 Lamport等人提出的解决方案的安全性。 依赖于同步，实际系统希望避免由于复杂性而导致的依赖性，并且因为它使系统暴露于DoS对安全的攻击。

代替同步假设，由Ben-Or [13]开创的随机算法保证了高概率的进步。 一系列研究逐渐提高了此类算法的可扩展性，包括[14]  -  [17]。 但是，大多数实际系统尚未纳入随机化。 在未来，LibraBFT可能会采用某些随机化来阻止自适应攻击。

Dwork等人介绍了一种不同的异步设置方法[18]，将安全（在任何时候）从活性（在同步期间）分开。Dwork等人引入了一个轮逐轮的范例，每一轮都由指定的领导者驱动。一旦诚实的领导者出现，就会在同步期间保证进展，并且在此之前，轮次会因超时而退役。 Dwork等人的方法（DLS）是迄今为止大多数实际BFT工作的基础，并且其性能得到了稳定的改进。 具体而言，它是Castro和Liskov [19]引入的第一个实用解决方案的基础，称为PBFT。在PBFT中，一个诚实的领导者在两个all-to-all的通信轮次中做出决定。除了最初的PBFT开源实现之外，该协议已经集成到BFT-SMaRt [20]中，最近已集成到FaB [21]中。Zyzzyva [22]为PBFT增加了一条乐观快速的轨道，当没有失败时，它可以在一轮中做出决定。Zyzzyva [22]为PBFT增加了一条乐观快速的轨道，当没有失败时，它可以在一轮中做出决定。Cachin [24]和Reiter [25]在共识协议中使用了使用门限加密的响应聚合，以all-to-collector和collector-to-all模式替换all-to-all通信模式，这种模式仅产生线性通信成本。门限签名聚合已被纳入几个基于PBFT的系统，包括Byzcoin [26]和SBFT [27]。 同样，LibraBFT结合了消息收集和快速签名聚合[28]。 与门限签名相比，LibraBFT中的签名聚合不需要分布式设置，并且以每个签名的每个节点一个额外比特的价格为选民提供经济激励。

两个区块链系统，Tendermint [29]和Casper [30]提出了一种新的PBFT变体，它简化了PBFT的领导者替换协议，使其仅具有线性通信成本（线性）。这些变体放弃了称为响应性的实用解决方案的标志性特征。非正式地，（乐观的）响应性允许当领导者在收到固定数量的消息时提出新的块而不是等待固定的延迟时。因此，Tendermint和Casper在实际的BFT解决方案中引入了一个权衡 - 它们具有线性或响应性，但不是两者兼而有之。LibraBFT所基于的HotStuff解决方案（以及其他最近的区块链，特别是具有名为PaLa [31]的变体的ThunderCore）解决了这种权衡，并提出了第一个具有两者的BFT共识协议。

在无权限的环境中达成共识。上面提到的所有作品都采用了允许的设置，即参与的玩家是事先知道的。 不同的是，在无权限的环境中，任何一方都可以加入并参与协议 - 这就是Nakamoto Consensus（NC）[7]旨在解决的问题 - 导致完全不同的协议结构。在NC中，交易（以块为单位）被链接并简单地通过工作证明传播到网络。确认是以概率方式定义的 - 块在历史中保留的概率与区块链中后续块的计算成本成正比。扩展现有供应链的奖励机制足以激励矿工接受当前的实际存在的链并迅速收敛于一个最长的分叉。Casper和HotStuff表现出类似的协议结构简单性。 他们将协议轮次嵌入到（可能是分支的）链中，并通过链的简单离线分析推断出提交决策。

几个区块链类似地基于直接非循环图（DAG）形式的块图，允许在将块发布到图中时具有更大的并发性，例如GHOST [32]，Conflux [33]，Blockmania [34]和Hashgraph [35]。我们对这些范例中的一些范例的经验表明，恢复图形信息并在参与者暂时失去连接后进行验证可能具有挑战性。 在LibraBFT中，只有领导者才能扩展链条; 因此，传播，恢复和验证图形信息很简单，基本上是线性的。

重温LibraBFT。 LibraBFT利用HotStuff（ArXiv版本[5]，出现在PODC'19 [6]中）并拥有上面四十年的工作所取得的许多好处。具体来说，LibraBFT采用DLS和PBFT循环方法，具有签名聚合，并具有线性和响应性。 我们还发现Casper和HotStuff的链结构导致了强大的实现和简洁的安全性参数。

与HotStuff本身相比，LibraBFT进行了许多增强。 LibraBFT提供了起搏器机制的详细规范和实现，参与者通过该机制同步轮次。这与活跃度分析相结合，该分析包含对交易承诺的具体约束。 LibraBFT包括验证者投票权（时期）的重新配置机制。它还描述了奖励提议者和选民的机制。 该规范允许导出安全和完整的标准来检测试图破坏安全性的验证者，从而使惩罚能够在将来纳入协议。 我们还详细阐述了验证者之间的数据传播协议，以同步其状态。

**组织：** 本报告的其余部分结构如下：我们首先介绍重要的概念和定义（第2节）以及如何在Libra区块链中使用LibraBFT（第3节）。本报告的其余部分结构如下：我们首先介绍重要的概念和定义（第2节）以及如何在Libra区块链中使用LibraBFT（第3节）。 然后，我们描述了LibraBFT及其网络通信层的核心数据类型（第4节）。接下来，我们将协议本身（第5节）提供足够的细节来准备安全证明（第6节）。 然后我们描述起搏器模块（第7节）并证明活力（第8节）。 最后，我们讨论了LibraBFT的经济激励（第9节），并在第10节中得出结论。

在这个初始报告中，需要代码的地方，我们选择使用Rust的最小子集作为协议的规范语言。我们提供在离散事件模拟环境中直接从我们的参考实现中提取的代码片段。 我们打算共享此模拟器的代码，并在后续版本的报告中提供实验结果。

# 2 概述和定义

我们首先描述LibraBFT的所需属性以及我们的状态机复制协议如何集成到Libra Blockchain中。

## 2.1 复制状态机

***复制状态机（SMR）*** 协议[36]旨在提供分布在网络上并在许多进程（也称为节点）之间复制的抽象状态机。

具体地，以一些初始执行状态启动SMR协议。 每个进程都可以提交命令并观察一系列提交。 每个提交都包含执行状态，该执行状态是在先前提交之上执行特定命令的结果。 在执行期间可能会拒绝命令：在这种情况下，它们被称为无效命令。

假设命令执行是确定性的，我们希望保证以下属性：

- **安全性** 所有诚实的节点都遵循相同的提交顺序。

- **活性** 只要提交了有效命令，就会生成新提交。

请注意，节点应以相同的顺序观察提交，但不一定要同时观察。 第2.3节中详细说明了诚实节点的概念。

## 2.2 时代（Epochs）

对于实际应用，参与协议的节点集可以随着时间的推移而发展。 在LibraBFT中，通过epoch的概念解决了这个问题：

- 每个时代开始时使用上一个纪元的最后执行状态 - 或者使用系统范围的第一个时代的初始参数。

- 我们假设每个执行状态都包含一个标识当前时期的值epoch_id。

- 当提交递增epoch_id的命令时，当前时代在该提交之后停止，并且下一个时代开始。

## 2.3 拜占庭容错

从历史上看，容错协议旨在解决常见故障，例如崩溃。 在区块链的上下文中，SMR共识协议用于限制系统中各个节点的权力。 为此，即使某些节点与协议任意偏离，我们也必须保证安全和活跃。

在本报告的其余部分，我们假设每个时代都有一个固定的，未知的恶意节点子集，称为拜占庭节点[3]。假定所有其他节点（称为诚实节点）严格遵循协议规范。 在给定的时代内，我们假设每个SMR节点α具有固定的投票权，表示为𝑉（α）≥0。我们为所有节点的总投票权写𝑁，并假设一个安全阈值𝑓作为𝑁的函数，使得𝑁>3𝑓。 例如，我们可以定义𝑓=（𝑁-1）/ 3。 对于本报告中的符号简单性，我们将𝑥的投票权称为𝑥节点。

我们在以下BFT假设的背景下分析所有共识属性：

  **bft假设** 任何时期内拜占庭节点的组合投票权不得超过安全阈值𝑓。
    
组合投票权𝑀满足𝑀≥𝑁-𝑓的节点子集称为法定集合（法定人数）。 以下经典引理[37]证明了法定集合的概念：

**引理B1：** 在BFT假设下，对于同一时代中两个法定集合的每个节点，存在一个诚实节点同时属于两个法定集合。

我们在6.1节中回顾引理B1的证明。

## 2.4 加密假设

我们假设散列函数和数字签名方案对计算有限的攻击者是安全的，并要求每个诚实节点对其私有签名密钥保密。

由于我们的协议只散列和签名公共值，我们可以假设所有数字签名都是强烈的非概率意义上的不可伪造的，这意味着任何有效的签名必须来自私钥的所有者。类似地，我们可以假设哈希函数永远不会发生哈希冲突，因此hash（𝑚1）=hash（𝑚2）意味着𝑚1=𝑚2。

## 2.5 网络假设和忠实者崩溃

虽然LibraBFT的安全性仅在BFT假设下得到保证，但活跃性需要对网络和流程进行额外的假设。具体来说，我们假设网络在坏连接和良好连接的时段之间交替，分别称为异步和同步的时段。 只有在足够长的同步期间才能保证活力。

在异步期间，我们允许消息丢失或占用任意长的时间。 我们还允许诚实的节点崩溃并重新启动。 在同步期间，我们假设在诚实节点之间的任何消息所采用的传输延迟存在上限δ𝑀; 此外，诚实的流程必须响应，不能崩溃。

我们必须强调，即使在同步期间，受到最大延迟δ𝑀的影响，攻击者也会控制恶意节点和网络消息的调度。

该模型的参数 - 例如δ𝑀的值或网络当前是否同步 - 对系统内的参与者不可用。为了简化分析，文献中通常只考虑两个时期：在某个未知的全球稳定时间（称为GST）之前和GST之后。我们的活性证明（第8节）将给出系统在GST之后产生提交所需时间的具体上限。

更正式地说，关于网络和崩溃的假设写成如下：

- 最终同步网络: GST之后，在一些（未知的）延时δ𝑀> 0内，网络在诚实节点之间传递所有消息。

- 最终没有崩溃：GST之后，诚实的节点完全响应，永不崩溃。

我们注意到GST模型没有考虑与消息处理相关的CPU时间。 此外，LibraBFT中的消息大小不受限制，因此，固定的δ𝑀可以说是过度简化的。 在将来的工作中，我们可以对消息大小实施严格限制，或者将每条消息的网络延迟视为固定延迟，传输延迟与消息大小成比例的组合。

## 2.6 领导者，投票，法定认证

LibraBFT属于基于领导者的共识协议系列。在基于领导者的协议中，验证者轮流取得进展，每轮都有一个称为领导者的指定验证者。领导者负责提出新的区块并获得验证人对其提案的签名投票。LibraBFT遵循HotStuff [5]的链式变体，其中每轮是一个单个指定领导者的通信阶段，并且领导者的提议使用加密哈希组织成链。在一轮中，领导者提出了一个扩展其知道的最长链的块。 如果提案有效且及时，则每个诚实节点都会签名并向领导发回投票。在领导者获得足够的投票以达到法定人数之后，它将投票聚合成法定人数证书（QC），再次延伸相同的链。QC广播到每个节点。 如果领导者未能组装QC，参与者将超时并进入下一轮。 最终，足够的块和QC将及时扩展链，并且块将匹配协议的提交规则。当发生这种情况，链上向上匹配的未提交块将变为提交。

# 3 与Libra区块链整合

## 3.1 共识协议

我们预计LibraBFT将用于Libra区块链[2]，如下所示：

- Libra的验证者参与LibraBFT协议，以便安全地复制Libra区块链的状态。我们将每个验证器运行的LibraBFT节点的软件实现称为SMR模块。从这里开始，我们将LibraBFT的参与者称为验证者节点，或简称为节点。

- 发送到SMR模块的命令是Libra事务的序列。 从SMR模块的角度来看，命令和执行状态是不透明的数据结构。 SMR模块将命令的执行完全委托给Libra的执行模块（参见附录A.1中的可能API）。 我们从执行状态中读取了epoch_id。 （回想一下，当提交对epoch_id的更改时，当前时代会停止。）

- 重要的是，，SMR模块还委托系统的剩余部分计算给定时代内的投票权。使用与执行层相同的回调（附录A.1）作为管理时代的回调来完成。为了获得更好的灵活性和透明度，我们希望这个逻辑能够在Move [38]中编写，这是Libra中可编程事务的语言。

- 每次需要执行命令时，执行引擎都会获得一个用于Move智能合约的时间值。 保证该值在执行相同命令的每个SMR节点上一致。

- SMR模块看到的执行状态不必是实际的区块链数据。实际上，在本报告中我们称之为“执行状态”的是轻量级数据结构（例如，散列值），其指的是存储在验证者的本地存储器中的具体执行状态。提交的每个命令必须由每个验证器至少在本地执行一次。将来，LibraBFT还可以包括一个附加机制，用于验证者通过本地存储与另一验证者相应的最近执行状态同步。

## 3.2 Libra 客户端

LibraBFT在验证者节点如何与Libra客户端交互的设计上是基本独立的。 但是，我们可以提出以下意见：

- Libra客户端提交的事务首先使用内存池协议在验证者节点之间共享。 当需要提出提案时，共识领导者会从内存池中提取交易。

- 为了验证与Libra客户端相关的区块链状态，在协议期间，LibraBFT节点签署了简短的承诺，以保证特定的执行状态正在提交。这导致加密提交证书可以独立于LibraBFT的共识协议的细节进行验证，前提是Libra客户端知道相应时代的验证者密钥集。我们将在章节（第4.1节）中描述如何与共识数据一起创建承诺。

- 关于这最后的假设，目前，我们将考虑Libra客户端可以从与一个或多个可信验证者的传统交互中学习验证者密钥集。 将来，我们将为此目的提供安全协议。

## 3.3 安全

区块链应用程序还需要额外的安全注意事项：

- 协议的参与者应该能够限制他们分配给其他节点的资源量（例如，CPU，内存，存储等），以确保尽管有拜占庭行为的实际活跃度。我们将在下一节（第4节）中看到，我们的数据通信层提供了让接收者控制它们消耗多少数据（即背压）的机制。对本报告的未来版本进行更彻底的分析。

- 理性节点的经济激励应与SMR协议的安全性和性能保持一致。我们在章节（第9节）中描绘了能够奖励和惩罚的低级机制。

- 领导者可能会受到针对性的拒绝服务攻击。 我们的起搏器规范（第7节）概述了如何引入可验证的随机函数（VRF）[39]，以一种较不可预测的方式将领导者分配给整数。在未来，我们还可能影响领导者选择，以便更频繁地选择健全的领导者。 在系统级别保护节点超出了本报告的范围。

**关于公平的说明：** 除了安全性和活性之外，SMR系统中经常讨论的另一个抽象属性是公平性。传统上，这个概念被定义为诚实节点提交的每个有效命令最终都被提交的事实。 然而，这个经典的定义与诸如Libra之类的区块链应用程序的相关性较低，其中交易首先通过共享的内存池进行，并且需要进行交易费拍卖。 在未来工作中，我们在讨论公平性。

# 4 共识数据和网络

在本节中，我们将介绍LibraBFT的核心数据类型，称为记录，并讨论用于通过网络同步节点状态的通信框架。

## 4.1 记录

LibraBFT节点的核心状态由一组记录组成。 我们定义了四种记录：

- *区块：* 由领导者在给定的轮数中提出并包含要执行的命令

- *投票：* 节点为一个块及其执行状态投票

- *法定认证（QCs）：* 其中包含对于给定块及其执行状态的法定数量的投票 - 以及可选的对Libra客户的承诺。

- *超时：* 节点通过它来证明其当前轮次已达到超时。

Rust中的精确数据结构将在下一段中提供。 最重要的是：

- 记录由作者签名。

- 块被链接（图2）：它们必须包括较低轮的块的QC的哈希 - 或者在时代的开始处，在时期的初始化期间设置的固定散列值ℎinit。

- 投票和QCs包括作为投票对象的块哈希和执行状态。

根据当前时代的投票权，通过收集相同执行状态的足够法定票数（第2.3节）来形成QC。法定认证由其作者签署的事实对协议来说并不重要：这仅仅是为了限制下一位领导人对选民奖励的影响（见第9节关于经济激励）。

投票和QCs包括为Libra客户端准备的可选承诺值。当投票人检测到在已投票块上收集QC将触发链中较早块的提交时，它必须使用该较早块的执行状态填充字段commitment（另请参见下面第5.3节中的提交规则）。通过这种方式，具有非空字段commitment的QC充当提交证书 - 即，提交特定状态的简短加密证明。由于我们在QC中包含了时代标识符，因此只要知道该时代的验证者集，就可以单独验证这种提交证书。

由于与数据同步消息相关的技术原因，我们在投票和QC中包括冗余的整数（附录A.3）。

必要时，我们将区分网络记录 - 刚刚从网络接收的记录 - 来自经过验证的记录，这些记录已经过彻底验证，以确保在下一节中定义的强不变量（第4.2节）。 但是，当上下文清楚时，我们通常会使用记录来验证记录。

重要的是，由记录验证（例如，链接规则）强制执行的不变量和初始条件保证一个给定时代的记录形成树 - 除了超时没有上链的。对于每个节点，保存时代记录的数据结构称为记录存储。如果一条记录存在于节点当前时代的记录存储中，我们说节点知道这条记录。我们在附录A.2中描绘了记录存储对象的可能接口。 我们将明确节点何时可以从其记录存储中删除（清理）记录，以最小化存储，作为5.7节中协议描述的一部分。

**Rust中的数据结构。** 我们假设以下原始数据类型：

- EpochId (整型).
- Round (整型).
- NodeTime (节点的系统时间).
- BlockHash and QuorumCertificateHash (哈希值).
- Author (共识节点的标识).
- Signature (数字签名).

LibraBFT的网络记录使用如下的Rust语法指定。

```rust
/// A record read from the network.
enum Record {
    /// Proposed block, containing a command, e.g. a set of Libra transactions.
    Block(Block),
    /// A single vote on a proposed block and its execution state.
    Vote(Vote),
    /// A quorum of votes related to a given block and execution state.
    QuorumCertificate(QuorumCertificate),
    /// A signal that a particular round of an epoch has reached a timeout.
    Timeout(Timeout),
}
struct Block {
    /// User-defined command to execute in the state machine.
    command: Command,
    /// Time proposed for command execution.
    time: NodeTime,
    /// Hash of the quorum certificate of the previous block.
    previous_quorum_certificate_hash: QuorumCertificateHash,
    /// Number used to identify repeated attempts to propose a block.
    round: Round,
    /// Creator of the block.
    author: Author,
    /// Signs the hash of the block, that is, all the fields above.
    signature: Signature,
}
struct Vote {
    /// The current epoch.
    epoch_id: EpochId,
    /// The round of the voted block.
    round: Round,
    /// Hash of the certified block.
    certified_block_hash: BlockHash,
    /// Execution state.
    state: State,
    /// Execution state of the ancestor block (if any) that will match
    /// the commit rule when a QC is formed at this round.
    commitment: Option<State>,
    /// Creator of the vote.
    author: Author,
    /// Signs the hash of the vote, that is, all the fields above.
    signature: Signature,
}
struct QuorumCertificate {
    /// The current epoch.
    epoch_id: EpochId,
    /// The round of the certified block.
    round: Round,
    /// Hash of the certified block.
    certified_block_hash: BlockHash,
    /// Execution state
    state: State,
    /// Execution state of the ancestor block (if any) that matches
    /// the commit rule thanks to this QC.
    commitment: Option<State>,
    /// A collections of votes sharing the fields above.
    votes: Vec<(Author, Signature)>,
    /// The leader who proposed the certified block should also sign the QC.
    author: Author,
    /// Signs the hash of the QC, that is, all the fields above.
    signature: Signature,
}
struct Timeout {
    /// The current epoch.
    epoch_id: EpochId,
    /// The round that has timed out.
    round: Round,
    /// Creator of the timeout object.
    author: Author,
    /// Signs the hash of the timeout, that is, all the fields above.
    signature: Signature,
}
```

**哈希和签名:** 我们假设可以对记录的数据字段进行哈希以产生确定性哈希值。 通过确定性哈希，我们的意思是当且仅当数据结构的内容相等时，两个数据结构的哈希值应相等（另请参见第2.4节关于加密假设）。

记录的哈希应包括与类型相关的标记，后跟记录中的所有字段，但字段签名除外。 记录的签名适用于其哈希值。

QC中投票向量的签名是从QC作者选择的原始投票记录中复制的。

## 4.2 网络记录验证

在时代初始时，共识节点就QuorumCertificateHash类型的初始值ℎinit达成一致。例如，我们可以用某些固定值的种子定义$ ℎ_init= hash（seed \parallel epoch\_id）$。

每个共识节点都会顺序验证它从网络接收的所有记录：

- 所有签名都应该是来自当前时期节点的有效签名。
- BlockHash值应引用先前验证的块。
- QuorumCertificateHash值应引用已验证的法定认证或初始散列ℎinit。
- 对于块链和法定认证中的连续块，应严格增加轮次值。 建议块中的轮次值在每个时代从第1轮重新开始。
- QC的作者应该是前一个块的作者。
- 超时，投票和QC中的时代标识符必须与当前时代匹配。
- 投票和QC中的轮次值必须与认证区块的轮次相匹配。
- 投票或法定认证中的承诺值应与提交规则一致（第5.3节）。 如果承诺值存在，则应由与认证块相同的作者集签名。
- 应跳过验证失败的网络记录。

鉴于块和QC的散列的约束，除了超时之外，节点已知的已验证记录形成树，其根是值ℎinit（引理S1）。

## 4.3 通讯框架

在LibraBFT中，通信框架构建了一个点对点的覆盖，用于在验证者之间可靠地传播协议记录（第4.1节）。框架API由两个原语动作组成：（i）发送，节点用它拥有的记录更新一个节点; （ii）广播，节点向所有同伴传播更新。

为了向诚实的节点提供可靠的传输保证，LibraBFT在点对点同步协议之上构建了gossip覆盖。简而言之，对于某个固定值𝐾（0 <𝐾≤𝑁），希望广播的节点将其数据发送到至少𝐾个节点的随机子集。接收节点以相同的方式转发相关数据。

在网络操作期间发送和转发的“相关”数据的确切性质是LibraBFT协议描述的一部分（第7.11节）。在第一次阅读中，可以简单地认为，节点在每次更新其记录存储时都会转发它所知道的每个有效记录。

从以下意义上说，转发数据对于广播行为的可靠[24]非常重要：如果诚实节点接收（相关）数据，那么 - 很可能 - 其他所有诚实节点将在不久之后知道这些数据。重要的是，即使数据的来源是恶意节点，这也成立。

随机八卦（gossip）提供以下广播保证：

    概率-可靠-广播: 在GST之后，如果一个诚实的节点接收或拥有需要闲聊的数据，那么-在很高的概率-在（未知）时间延迟δ𝐺> 0之前，每个其他诚实节点都将接收到这些数据。
    
我们从广义上解释了这一要求，允许在此过程中更新数据。 我们还允许几个发送人在一段时间[𝑡1; 𝑡2]内并行启动相同数据的闲聊，并假设所有诚实节点在时间𝑡2+δ𝐺时都会收到数据。

**选择扇出系数的注意事项** 作为网络延迟和可扩展性之间的权衡，扇出因子𝐾的选择通常远小于节点数。我们将如何选择一个𝐾值的工作留给以后，以便单个消息在GST之后遵循经典假设（最终同步网络）。现在，我们可以简单地选择𝐾=𝑁（节点数），并让δ𝐺=δ𝑀。

## 4.4 数据同步













