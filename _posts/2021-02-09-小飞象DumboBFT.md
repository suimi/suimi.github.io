---
layout: post
title: 小飞象(DumboBFT)
tags:
- 共识协议
- DumboBFT
categories: 区块链
---
* TOC
{:toc}

术语：
ACS：异步公共子集协议（Asynchronous Common Subset）

ABA：异步二进制协议（Asynchronous Binary Agreement protocol）

RBC：可靠广播协议(Reliable Broadcast Protocol）

MVBA: 多值验证拜占庭协议(multi-value validated Byzantine agreement)

摘要。HoneyBadgerBFT是Miller等人[35]提出的第一个实用的异步原子广播协议，它展示了令人印象深刻的性能。 HoneyBadgerBFT (HB-BFT)的核心是利用Ben-Or等人的异步公共子集协议(ACS)实现批处理共识，由n个可靠广播协议(RBC)组成，每个节点提出自己的输入，然后n个异步二进制协议(ABA)对每个建议值(n为节点总数)做出决策。

本文提出了两种新的原子广播协议(Dumbo1, Dumbo2)，它们都具有渐近的和实际的更好的效率。特别是，Dumbo1的ACS只运行很小的$\kappa$个ABA实例(独立于n个实例)，而Dumbo2的ACS进一步将其降低为常数!我们的技术的核心是两个主要的观察结果:(1)减少ABA实例的数量显著提高效率;(2)更谨慎地使用多值验证拜占庭协议(multi-value validated Byzantine agreement, MVBA)，该协议被认为是[35]中ACS的次优方案，实际上可以导致更有效的ACS。

我们实现了Dumbo1和Dumbo2，并在100 Amazon EC2 t2上部署了它们和HB-BFT。介质实例均匀分布在全球10个不同的地区，并在相同的环境中进行广泛的实验。实验结果表明，我们的协议在延迟和吞吐量上都比HoneyBadgerBFT提高了好几倍，特别是当系统规模变大时。

<!--more-->  

# 1 介绍

拜占庭容错(BFT)协议使一组不受信任的对等体能够达成共识。作为分布式计算的一个基础研究领域，该问题已经得到了广泛的研究。BFT协议的一个主要分类是基于时间(或网络)假设。同步BFT协议假定所有诚实对等体发送的值都将在一定的时间内发送给接收方，这是每个人(包括协议设计者)都知道的。而部分同步的BFT协议则放宽了这一网络需求，允许存在但未知的时间限制。异步BFT协议最不依赖于网络假设，即它不需要存在这样的时间限制，只需要所有的值最终都会被传递。

最受欢迎的异步BFT。在早些年，考虑到BFT协议主要部署在对等体连接良好的传统内部场景中，BFT的研究努力集中在减少(加密)计算[5,41]，或增加协议可以容忍[21]的恶意参与者的阈值，假设网络是同步的。近年来，关于同步设置的Nice工作不断出现[11,1,33]。放松网络同步假设的努力也存在。一个值得注意的例子是经典的实用拜占庭容错(PBFT)协议[18]，它需要部分同步。然而，由于鲁棒性和效率的原因，在实际应用中完全取消同步假设变得越来越可取。

最近，加密货币和区块链技术的成功总体上为BFT协议带来了更广泛的应用场景，也证明了在广域网(WAN)上达成共识的可能性。开放的互联网环境提供了一个更具对抗性的设置，即对等体之间的网络延迟可以是时变的。然而，同步(或部分同步)BFT只能在连接良好的节点的相对“私有”网络中执行，以保证网络在一定的时间范围内交付。如果时间假设不成立，这些协议将无法取得进展，并陷入停滞。事实上，最近的工作[35]正式表明PBFT在“间歇同步网络”中无法取得任何进展，在这种网络中，对手只选择在特定的时间点延迟消息。这种“攻击”同样适用于一类基于leader的BFT协议[4,10,20,19,42,5]。

异步协议的另一个重要原因可能是由于效率，特别是一个称为响应性的属性。在设计同步BFT协议时，用假定的网络延迟作为参数，通常选择较大的网络延迟，使实际的网络延迟确实更小，从而保证了同步假设。因此，大多数同步BFT协议的效率取决于假定的网络延迟。而“响应性”则要求性能只与实际的网络延迟相关，因此它不应该依赖于任何计时假设，只要消息被传递，协议就会推进。

此外，众所周知，异步协议在实际构建分布式系统时大大简化了工程工作，因为不需要超时机制。在构建实现同步协议的系统时，应该设计各种特别的、容易出错的超时机制。

**第一个实用的异步BFT[35]**。尽管在真实的广域网中部署异步BFT在很多情况下是可取的，甚至是必要的，但在[35]中提出第一个实用的协议HoneyBadgerBFT之前，大多数关于异步BFT的研究都是理论上的。以前的异步BFT协议通常是低效的，例如，通信复杂度(每条消息)很高(如果有n个对等体，可以达到$O(n^2)$甚至$O(n^3)$[26,41,15,9,17,2]。随着系统规模的扩大，这些协议的性能将急剧下降。另一方面，HoneyBadgerBFT[35]的出色工作，提供了一些关键的观察结果，推动异步BFT向实用的方向发展。

第一个观察结果是，原子广播协议是对维护不断增长日志的BFT协议的持续执行(或者换句话说，常规BFT协议可以被视为它的一次性实例)，可以从称为异步公共子集(asynchronous common subset, ACS)的较弱变体和阈值加密方案轻松构建。ACS协议只要求对等体对它们所有输入的一个子集达成一致，最初提出这个协议是为了不同的目的[7]。

![The structure of ACS in HoneyBadgerBFT](/static/img/ACS_HoneyBadgerBFT.png)

更重要的是，在[35]中观察到，Ben-Or等人[23]提出的经典ACS协议在渐近和实际效率上都更有希望（比另一种称为多值验证拜占庭协议（MVBA）的相关协议 ）[15]（稍后将进一步解释），请仔细选择底层构建基块。 [9,35]中的ACS协议是基于两个子协议构建的：可靠广播（RBC）和异步二进制协议（ABA）。 结构非常简单：每个节点都调用RBC广播其输入值，并参与ABA协议的n个实例，以商定要包括哪些输入子集，见图1。

实验结果表明，HoneyBadgerBFT具有良好的性能。在[22]的出色工作中，作者对考虑不同部署场景时HB-BFT最合适的构建块实例(同时保持协议结构完整)进行了广泛的研究。我们选择了不同的道路，提出了以下问题:

  *我们能否重新设计ACS协议以提高其渐近性和实用性?*
  
## 1.1 我们的贡献

我们设计了两种新的ACS协议，这两种协议都能渐进地提高系统的运行时间。我们的实验结果表明，当它们在Amazon AWS上的相同环境中反复运行时，比HoneyBad- gerBFT[35]有了成倍的改进。更有趣的是，我们的两个主要观察结果(1。应该减少ABA实例的数量;2. 如果对ACS谨慎使用，MVBA将更有效)，导致我们的两个协议更有独立性
。让我们在下面详细说明。

Dumbo1:更快的异步BFT。首先，我们稍微详细地回顾一下HB-BFT中使用的ACS协议的结构:首先，每个对等体通过一个RBC实例广播其输入;当对等体从对等体Pi接收到值时，它将第i个ABA实例的输入设置为1，并启动ABA协议。一旦一个诚实的对等体从n - f ABA实例中得到1，它将输入0到所有剩余的还没有输入的ABA实例，然后继续。

识别主要瓶颈。 由于著名的FLP不可能[23]，ABA必须是随机协议。 这带来了以下缺点：尽管每个ABA协议的预期“回合”次数是恒定的，但运行n个并发ABA会话的预期回合数可能会很大，至少$O(log n)$[8] 更严重的是，这些ABA实例并不能真正以完全并发的方式执行：（1）并非所有实例都同时启动，因此某些实例可能由于未交付（先前RBC）的输入而稍后启动； （2）正常节点还面临着大规模并发执行的效率下降（CPU内核数量不足等）。 当n变大并且网络不稳定时，很可能会有一些ABA实例终止得很慢。 最慢的ABA实例确定HoneyBadgerBFT ACS的运行时间。

为了了解ABA协议对性能的实际影响，我们进行了HB-BFT实验，并对RBC和ABA之间的平均运行时间进行了统计。 如图2所示，很明显，对于HB-BFT，ABA的成本占主导地位2。随着系统规模的扩大，这种模式变得更加重要。 这种简单的观察启发我们减少了ACS协议中所需的ABA实例的数量。

![Batch size (txs)](/static/img/Batch-size-(txs).png)

减少ABA实例的数量。 我们重新设计了ACS的结构，并提出了Dumbo1-ACS。 与HoneyBadgerBFT（以及BEAT协议）不同，Dumbo1-ACS仅需要运行$\kappa$个而不是所有n个ABA实例，即可达到$O(log \kappa)$运行时间，其中$\kappa$是独立于n的安全性参数。 其他复杂性指标保持不变。

在简化视图中，第sdfaksdafjksadjfefjaksdlf;iwejfias一阶段保持不变：每个节点都通过RBC实例广播其输入。 然后，想象一下，如果我们有一个诚实的节点来担任领导者，那么它可以先完成n-f个RBC实例，然后通知所有其他节点输出这些RBC实例的交货。 为了获得这样一个诚实的节点，我们可以选择少量的$\kappa$个节点作为“领导者”，以使其中至少有一个是诚实的。

由于现在两个诚实节点可能会从不同的选定“领导者”那里收到不同的值，因此需要进一步的注意。 接下来，我们应该使诚实节点能够确定要选择的$\kappa$个选定节点中的哪个。 它实际上变得类似于HB-BFT，我们可以调用ABA实例以确认要包含的子集的提名。 一旦一些ABA实例输出1，就可以识别并输出相应的消息。 重要的是，现在对等方只需要在$\kappa$个节点（可能比n个小得多）上达成共识。 参见图3中的图示。

![The structure of Dumbo1-ACS](/static/img/Dumbo1-ACS.png)

我们想强调的是，其余部分的变化保持在最小程度，因此ABA实例的减少也带来了重大的实际改进。 看起来我们比HB-BFT有少量额外的RBC实例； 但是，我们在这些额外的(索引)-RBC实例中将每个对等方的输入设置为一个很小的索引集（用Si代替实际的数据负载）。 一个诚实的玩家如果确实收到与Si对应的所有消息，则为第i个ABA输入1。 此外，为选择$\kappa$个节点而添加的投币协议只是ABA协议的子例程。 因此，与消除ABA实例的成本相比，那些增加的开销将是不明显的。

看看为什么它工作:当一个诚实的节点决定输出对应Si的值，它必须是第i个ABA实例输出1位的情况。ABA的属性确保了(1)所有其他诚实节点也将输出1，(2)至少有一个诚实节点为这个ABA实例输入1。后者意味着至少有一个诚实的节点确实接收到索引集Si对应的所有输入值是${v_j}$。因此，遵循RBC的安全性，所有其他诚实的节点最终也将收到这些值。而条件(1)确保所有诚实的节点将实际输出相同的值子集。

**Dumbo2:一个更快的异步BFT**。Dumbo1现在只运行k个并发的ABA实例，我们现在问一个更有野心的问题:我们能把它一直推到常数吗?

将ABA推至最小值。HoneybadgerBFT需要执行n次ABA实例，因为每个ABA实例只确定来自一个对等体的输入。Dumbo1可以减少它，因为现在“委员会”成员已经准备好了一个值向量。但是，Dumbo1仍然需要运行k个实例:RBC阶段之后的过程非常类似于HB-BFT的结构，它选择一个包含索引集${S_i}$的公共子集作为元素。因为每个节点将调用/输入第i个ABA实例，一旦它从第i委员会接收到Si和所有与Si对应的值。这导致了一个挑战，不同的节点可能会进入不同的ABA实例，这些实例没有“全局协调器”，因此唯一可行的方法是并发运行所有的实例。

原则上，我们仍然“浪费” $\kappa - 1$个ABA实例。这启发我们找到一种方法来正确地识别一个输入向量，从而导致我们重新检查多值验证拜占庭协议(multi-value validated Byzantine agreement, MVBA)的适用性，它输出n个对等体中的一个输入，只要输入满足某些预定义的谓词。在[35]中, MVBA被认为不适合构建ACS。原因是现有结构通信复杂度高，即[15]中的MVBA协议在预期3中通信复杂度为$O(n^2\vert m\vert + \lambda n^2 + n^3)$，其中$\vert m\vert$表示MVBA输入值的大小。在许多情况下, $\vert m\vert > \lambda n(log n)$,因此,控制项的每条消息通信直接施工的ACS [15] $O(n^2 \vert m\vert) = \Omega(n^3)$(尽管[15]并没有明确提到ACS,其原子广播已经包含建设MVBA ACS,和最近的复杂性仍然甚至改善MVBA[2]),使MVBA协议用于构建ACS的不切实际。

但是，只有当MVBA直接调用大尺寸输入时，上述说法才成立。如果我们仔细观察，我们注意到，如果$\vert m\vert$很小，那么MVBA的整体通信复杂度(以及相应的ACS[15])并不比HoneyBadgerBFT中的ACS大，甚至要小很多! 见第6节的表1。而且MVBA具有ABA实例数量恒定的好处[15]。关键的挑战现在被简化为如何在输入较小的情况下调用MVBA来构造一个可能仍有较大输入的ACS。这让我们想起了在密码学的环境中被广泛使用的 "混合加密 "的传统智慧。

![The structure of Dumbo2-ACS](/static/img/Dumbo2-ACS.png)

应用MVBA的正确方法。我们通过对MVBA的创新使用，提出了一个更快的异步BFT协议，我们称之为Dumbo2。它实现了渐进最优（恒定）的运行时间，即Dumbo2只需要运行（预计）三个连续的ABA实例，其他复杂度保持不变5。

要想解决ACS的细节问题，需要进一步的思路。由于ACS输出的是输入的子集，所以我们首先会通过RBC类型的协议为每个对等节点准备一个输入的向量。更重要的是，我们不把这些消息向量输入到MVBA协议中，而是进一步给每个对等节点准备一个很短的 "指示器"（图4中的$W_i$），并把它作为输入加入MVBA协议。MVBA协议将输出一个这样的 "指示器"，用来通知每个诚实的对等体挑选相应的RBC实例。棘手的是，在MVBA协议中，诚实的对等体可能会输出来自恶意对等体的输入（这里是短的 "指示器"）。

我们通过设计 "指示器 "的方式来解决这个问题，任何一个 "指示器 "都可以作为所有诚实的对等体收到相应消息的保证。我们制定了一个新的基元，称为可证明的可靠广播（PRBC），它增强了RBC，并进一步输出一个简洁的证明（即使是恶意节点），证明至少有一个诚实的对等体已经收到了输入。这可以通过RBC索引上的阈值签名来实现。MVBA内的ABA只需要重复（预计）三次。参见图4的图解，其中$\pi$是一个随机的排列组合。

来看看它为什么会工作：MVBA的实际输入$W_i$包括一个指数集和相应的证明。当一个诚实节点输出$W_i$时，$W_i$中的证明是有效的。这意味着$W_i$中的指数对应的消息都被足够多的对等体接收到了，而这些对等体中至少包括一个诚实的对等体。那么所有其他诚实节点最终也会收到这些消息。

我们指出，尽管Dumbo2在大多数情况下都优于Dumbo1，但为了表述的清晰，我们选择保留Dumbo1：在Dumbo1中使用每个ABA来投票是否输出每个 "委员会 "成员的向量，而不是像HB-BFT中的每个输入，这个想法是简单而直观的。这种更有效的投票的可能性可以看作是激励投票只输出一个人的向量的想法的垫脚石，最终导致Dumbo2使用MVBA的想法。另外，由于MVBA还是相当复杂的，在一些良性的情况下，当f非常小的时候，Dumbo2未必比Dumbo1好。

![Running time breakdown of Dumbo1/2 and HoneyBadgerBFT on one random node](/static/img/time-breakdown.png)

实现和实验评估。除了渐进式的改进（见第6节表1），我们还实现了Dumbo1和Dumbo2，并在实际的广域网环境中测试了我们的方案的性能。我们在100个Amazon EC2 t2.medium实例上部署了Dumbo1、Dumbo2和HoneyBadgerBFT，这些实例均匀地分布在全球10个不同的地区。为了公平比较，我们使用了与[35]相同的语言和密码学库，并在相同的环境下进行了各种测试。结果表明，我们方案的效率确实比HB-BFT高出数倍，尤其是当系统足够大时。例如，当n=100时，Dumbo1的基本延迟只有22%，Dumbo2的延迟只有HB-BFT的5%。此外，Dumbo1的峰值吞吐量为$3.5/times$，而Dumbo2的峰值吞吐量为HB-BFT的$9/times$以上。关于更多测试的细节请参见第7节。

为了展示我们观察到的减少ABA实例数量的有效性，我们从一个实验中选取结果（随机节点记录的每个子协议的运行时间），其中n=32，105个事务（每个250字节）作为输入，见图5。在图中，对于每个协议，每一行表示一个子协议实例的执行情况，例如，HB-BFT第一行的两根柱子分别对应第一个实例RBC1和ABA1，第二行对应第二个实例RBC2/ABA2，以此类推。Dumbo2中的一致广播(CBC)协议是MVBA的一部分，可以看作是RBC的简化版(详细定义见附录)。

## 1.2 相关工作

共识问题最早是由Shostak、Pease和Lamport[28]提出的。作为分布式计算中的一个基本问题，它受到了广泛的关注，以至于许多不同的共识问题的变体都被研究了，例如[27,39,18,25]。

关于异步BFT的经典研究更多的是集中在理解其理论上的局限性和可行性。著名的FLP-不可能性[23]表明，在异步环境下，只要一个节点可能崩溃，就不可能有确定性的共识协议。相反，Ben-Or[7]和Rabin[40]展示了如何通过随机化来规避不可能性。这些开创性的工作激发了许多其他经典的工作，沿着异步二进制协议（ABA）[7,13]的路线，它认为每个节点的输入只是一个位。众所周知，ABA协议是构建全边缘BFT或原子广播协议的重要组成部分[15,26,41,35,22,2,24,36]。我们观察到(并在实验中验证了)，运行大量的ABA实例成为效率的瓶颈，我们努力将其使用量降到最低。

HoneyBadgerBFT[35]是第一个实用的异步原子广播协议，它有两个主要的观察。(1)最初由Ben-Or等人[9]提出的异步共同子集(ACS)这个较弱的问题可以很容易地转换为原子广播，而不需要太多的开销；(2)由可靠广播(RBC)和异步二元协议(ABA)构建的ACS协议，经过仔细的实例化，超过了之前直接由多值拜占庭协议(MVBA)构建的思路[15]。

HoneyBadgerBFT最近的一些实际改进来自BEAT[22]和Aleph[24]的优秀作品。特别是，BEAT仔细研究了不同的用例，并提出了在实践中选择部署合适的组件的建议。更详细的说，除了BEAT3,4只针对BFT存储，他们还提出了BEAT0-2来满足不同的目标。BEAT1和BEAT2中的组件选择得很微妙，即使对于合理的大消息，通信复杂度似乎较大，但如果消息大小较小，实际上它们的速度更快，见第6节的表1。Aleph试图通过对事务缓冲区提出不同的假设来改善延迟获得对数n因子的改善，然而，ABA仍然在影响延迟，这样延迟仍然需要$O(log n)$。Aleph的一个有趣的技术是去除可信交易商假设，这也可能用于我们的Dumbo协议中。

正如我们前面简单提到的，我们的方法和BEAT是正交和兼容的：他们的工作保持了HoneyBadgerBFT的结构不变，因此具有相同的回合复杂度，但挑剔了底层组件的最佳瞬时性；我们专注于重组ACS协议，但大多数组件是相同的。他们从BEAT0-BEAT2的技术也都可以应用到我们的协议中。所以在实验上，我们专注于与HB-BFT的比较。将他们的所有技术与我们的技术结合起来，将是未来有趣的工作。

# 模型和问题陈述

## 系统模型

现在我们描述一下我们的系统模型。

**设置**。具体来说，它涉及一组指定的n个节点${P_i}_{i\in[n]}$，我们用[n]来表示整数{1,2,...,n}。我们认为这些节点的身份是公开的，例如，由PKI认证。我们用$(PK_i，SK_i)$表示节点$P_i$的公钥/私钥对。除了已经建立的身份之外，一个可信的第三方也会在协议之前运行，以建立所有涉及的阈值密码系统。


- [Honey Badger of BFT](https://zhuanlan.zhihu.com/p/44524558)