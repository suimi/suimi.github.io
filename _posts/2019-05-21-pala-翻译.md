---
layout: post
title: pala中文
tags: 
- 共识协议
- pala
categories: 区块链
---
* TOC
{:toc}

# 1 绪言

我们描述了PaLa，一种概念上简单的，部分同步的区块链协议，可以容忍少于1/3的作恶。 在PaLa，提议者提出了一个块，扩展了迄今为止看到的最新鲜的公证链。 如果满足某些条件，共识节点（即委员会成员）就该提案进行投票。 当一个区块获得至少2n/3票时，它就会变成公证。 有效区块链中有两种类型的块，正常块和超时块，并且每种类型都有一组不同的有效性约束。 在任何时间点，公证链中的每个块直到最后一个正常块（不包括）都被认为是最终确定的。

PaLa的设计精简。 消息提议和投票只有两种类型。 在良好的条件下，每个区块只需要进行一轮投票即可确认 - 但是为了最终确定，必须等待下一个正常区块获得公证。

总的来说，关于提议者选举存在两种学说：支持民主的方法（例如，Dfinity [11]，Algorand [8]）为每个确认的区块切换提议者; 和稳定性有利的方法（例如，PBFT [7]和Thunderella [14]）。 我们的范例允许使用任一策略。

我们还描述了一种简单的方法，用于在不等待任何同步事件的情况下更改委员会，同时保持协议的简化执行。

## 1.1 Pipelined-BFT范式的背景
经典型BFT协议使用两轮或多轮投票来确认每个块，例如在PBFT中，它们分别被称为“prepare”轮和“commit”轮。最近，加密货币社区出现了一个优雅的流水线理念，即，如果每个块需要两轮投票，为什么不在第二轮投票中捎带？这个想法在Buterin和Griffith [15]的优雅Casper-FFG作品中被隐含地描述，其形式为终极小工具“用于工作证明区块链。论坛和在线博客帖子[2,3]表明DPoS （即，EOS采用的共识协议，按市值排名前5的加密货币[1]）可能正在考虑采用类似的方法，尽管在撰写本文时尚未发布对DPoS协议和证据的正式描述。 Casper-FFG [15]和DPoS [2,3]的这种想法的实例都只实现了同步性能，即，即使网络能够更快地传送数据包，这些协议也只能以较慢的间隔确认块。 DPoS仅以固定间隔提出块[2,3]，而在Casper [15]中，块提议是进程是潜在的PoW区块链，因此块提议仅偶尔以随机间隔发生。

Abraham等人最近的优雅作品HotStuff。 [4]扩展了这种“流水线”方法，以提供可证明安全的BFT协议，容忍部分同步网络中的2/3损坏。在高层次上，PaLa依赖于与HotStuff非常相似的直觉（但我们给出了一些 - 在实现中可能有价值的更简单的想法表示）。在HotStuff中，活跃依赖于拥有一个旋转的提议者（即“支持民主的方法”），而在PaLa中，我们还展示了如何使用适合性能要求的场景的稳定性偏好的提议者轮换策略来实例化PaLa（参见章节 9关于具体的，现实世界的应用场景的更多讨论）。此外，我们提出了一种双流水线变体，它是对性能要求严格的场景所必需的流水线-BFT范例的进一步概括。此外，如上所述，我们提出了一种简单的方法来启用委员会切换（我们考虑的应用程序也需要这种方法）。

## 1.2 协议概述
我们在此提供PaLa共识协议的描述，重点是“随机”提议者选举政策和固定委员会。设$\Delta$是同步期间网络延迟的约束。由于我们处于部分同步模型中，协议只需要在同步期间取得进展，但一致性/安全性应始终保持在任意网络分区之下。为了简化表示法，我们将使用别名秒为$ c\Delta $，别名分钟表示为$ c^2\Delta $（即c秒）表示某些适当的常量c（在实际协议中c = 6）

每个节点保持一个从0开始的本地时期计数器e和当前的一个块链（b1, b2,...,bn）;每个块具有形式（e,TXs,h_1），使得时期数e严格增加，并且h_1是当前块之前的链的散列。我们说如果$ \pi $包含来自链中每个块的 >= 2/3的有效签名，则$ \pi $是链的公证。链的纪元号被定义为最后一个块的纪元号。该协议如下：    

<!--more-->  

- **更新链**：每个节点都存储到目前为止所见的最新的公证链c。 当一个节点看到一个有效的链c'（上述形式）带有公证时，其时代号高于其当前链c的时期号（我们称c'比c更“更新”）c'替换当前链。
- **块提案**：在每个时期e中，通过将哈希函数（随机预言）应用于时期号而确定的随机节点被选为“提议者”。 提议者进行如下：
    - 如果提议者的链以一个时期块e-1结束，则提议者可以立即提出一个新块（e; TX; H（c））并将其多播，其中TX表示要确定的未完成事务。
    - 如果提议者的链具有早于e-1的时期，（如先前的提议者未能将其块包含在链中），则等待1秒（以便可能接收“更新鲜的”链），之后提出一个新的块（如前一种情况）。
- **公证**：在时期e，每当节点i从时期e的提议者接收块（e; TXs; h_1）时（1）它已经看到与h_1一致的公证链c-1，并且（2）c-1是 至少和时代e开始时的链条一样新鲜，并且（3）它之前没有为时期e签署过块，i对块签名并进行广播。
- **时代推进**：无论何时发生以下事件中的任何一个并且当前处于小于e的时期，节点i前进到时期e：（1）它看到用于纪元e-1的公证链，或者（2）它接收到>=2/3节点数个带签名的clock(e）消息。 如果自节点进入纪元e-1以来已经过了一分钟，它将组播clock(e）。

**蓝图**.上述协议称为基本PaLa，将在第3节中正式描述，并在第4节中证明是安全的。

然后，我们重点描述PaLa的概括，称为双重流水线PaLa，面向高性能场景。 这个应用程序是由ThunderCore推动的，ThunderCore是一个区块链公司，旨在将以太坊转移到被称为“加速器”的专用基础设施节点（即提议者）加速的“快速路径”。 我们还描述了使用PaLa执行委员会重新配置的简单但非平凡的技术。

# 2.模型
## 2.1 部分同步网络建模
**背景:与GST建模部分同步.** 我们采用部分同步通信网络，我们的正式模型是Dwork，Lynch和Stockmyer [10]提出的“全球稳定时间（GST）”模型的扩展。 回想一下GST模型假设如下：

- 最终，在被称为GST的一些点，网络将是稳定的和忠实的消息将在$\Delta$的时间内传递。
- 部分同步协议提供参数$\Delta$但协议不知道GST。

**长时间运行的部分同步建模.** 由Dwork等人提出的GST模型。 [10]更适合单发一致性协议。 相比之下，区块链协议是长期运行的，确认了不断增长的，线性排序的日志（例如，交易）。 因此，我们将GST模型扩展为适合这种长期运行的场景。

我们正式定义了一个称为同步周期的概念。 直观地，一段同步是当网络连接良好并且忠实节点或多或少同步时，它们可以彼此通信经历最大$\Delta$延迟。 然而，有时，网络可能失去同步，例如，在重大中断或分区期间。 当发生这种网络分区时，部分同步协议应该保持一致性。 另一方面，只有在同步期间才需要活跃度。 一种部分同步协议知道参数$\Delta$
（即，协议描述中固有$\Delta$），但不知道当同步的周期会发生。

**定义1(同步周期)。** 修正一些协议执行。我们说周期[t0, t1]是同步期(w.r.t.执行)，当且仅当一个忠实节点在其本地时间t<=t1发送的每条消息在其本地时间max(t0, t +$\Delta$)之前也会被任何其他忠实节点接收到。

我们注意到，在一些关于部分同步共识的现有工作中已经采用了“同步时期”这个术语（有时是非正式的）[4,5]。 上述定义1是我们对本文采用的这一概念的明确表述。

为了方便起见，在本文中，除非另有说明，否则我们假定节点总是通过向每个人多播消息来响应它看到的每条新消息—注意，所有消息都将在我们的协议中签名。这样，我们可以做出一个更强的同步假设:

**定义2(较强的同步周期概念)。** 我们说周期[t0, t1]是同步的周期(w.r.t.此执行)，当且仅当一个忠实节点在其本地时间t <= t1观察到的每条消息在其本地时间max(t0, t + $\Delta$)之前也将被任何其他忠实节点观察到。

**备注1.** 在整篇论文中，我们可以假设节点允许有界时钟偏差，在这种情况下，忠实节点之间的最大时钟偏差被符号$\Delta$吸收。

## 2.2 执行模型和假设
总共有n个节点编号为1,2，...，n，其中n是公知参数。 我们假设公钥基础结构（PKI）和第i个节点的公钥表示为pki，并且相应的密钥表示为ski。

**作恶模型。** 我们假设一个多项式有界的对手可以破坏少于n / 3个节点。 为简单起见，我们将首先在静态损坏模型下证明安全性，其中攻击者在开始执行之前做出作恶选择。 稍后在A.1节中，我们将解释如何将我们的安全保证扩展到自适应损坏，即，当攻击者在协议执行过程中自适应地破坏节点时。

在本文中，我们假设所有忠实节点在0时刻开始执行协议。

# 3.热身：基本的PaLa
## 3.1定义和符号
**单位时间的别名。** 为方便起见，我们使用术语一秒钟（或简称为秒）和一分钟（或简称为分钟）不通过挂钟测量时间，而是作为特定时间单位的别名（即输入到协议的参数）。 在整篇论文中，我们假设如下：
$$
1sec \geq 5\Delta \quad and   \quad 1min \geq6sec
$$

**有效块:** 现在块的形式为（e,TXs, h_1），即，我们不再需要块中的时间戳字段; 此外，现在每个块都带有一个时代号 $ e \in N $。 TXs和h_1的定义如前所述。

**区块链定义：** 一个有效的区块链，表示c，是一个有序的块序列。
因此，我们使用以下符号:
- c[i]表示链中第i个block，其中$1 <= i <= \mid c \mid $;为了方便起见，我们假设每个区块链c前面都有一个虚构的genesis块$c[0]:= ((0,1),\bot,\bot,0)$;
- c[: i]表示直到第i个块(含)的所有块;
- c[-i]是c[L -i + 1]的别名，其中$L = \mid c \mid $;和

**区块链的有效性。** 一个区块链当且仅当满足如下条件时是有效的：
1. 对于每$1 <= i <=\mid c \mid $， c[i].h_1 = H(c[: i - 1])。
2. 对于任何$1 <= i <j <= \mid c \mid $，它必须是c [i] .e <c [j] .e，即有效区块链中包含的纪元数必须严格增加（但可能 跳跃）。
    
    我们稍后将在基本PaLa方案的证明中使用以下术语: 如果c [i] .e = c [i-1] .e + 1，则c [i]被认为是正常块; 否则它被称为超时块。

**“更新鲜”的关系:** 我们说c比c'更新，如果c [-1] .e> c'[ -1] .e。 如果c [-1] .e = e，我们也说c链是历元e链。像以前一样，我们有时使用术语“块”作为以该块为结尾的链的(前缀)的别名。

**投票和公证:** 如果$\sum.verify(pki, H(c),\sigma)= 1$，则签名$\sigma$被认为是来自节点$i\in[n]$的有效投票，其中pki表示节点i的公钥和$\sum$表示正在使用的签名方案。

**备注2(区块作为链的别名):** 注意，由于每个块都引用它所扩展的父链的散列，所以我们经常使用术语“块”作为以该块结束的链的别名(假设没有发生散列冲突)。例如，当我们说一个区块上的投票或公证时，它与在该区块结束的链上的投票或公证是一样的。

**提案人资格:** 我们假设节点$i \in [n]$是历元e的一个合格的提议者，当且仅当$ i=(H^\*(e) mod n) + 1 $，其中$ H^\* $是在竞争对手决定破坏哪个节点之后由随机预言机选择。

## 3.2 协议

**内部时钟同步：** 每个共识节点维护本地时钟指示当前时期（以下称为节点的本地时期）。 起初，本地时期设置为1.节点使用以下机制来推进其本地时期：

- 如果节点已经在本地时期超过1分钟，则签名和多播时钟（e + 1），表示它想要前进到时期e + 1（但此时还没有推进到e + 1）。

- 在看到epoch-（e-1）块的公证时，或者在看到来自至少2n / 3个不同节点的签名时钟（e）消息时，将本地时期推进到e（如果本地时期小于e）。

**提案:** 当节点处于本地时期e时，根据以下哪个情况先发生，选择一个块B提议（如果可能）：

- 它看到一个时期为epoch-（e  -  1）的公证链c，然后如果符合条件，则建议块B：=（e，TXs，H（c））其中TXs是未完成交易的集合。

- 否则，如果自进入时期e已经过了1秒，则选择到目前为止观察到的最新的公证链c，如果符合条件并且B是从c延伸的有效块，则建议块B：=（e，TXs，H（c））。 

请注意，忠实节点在同一时期建议不超过1个块。此外，如果一个提议者因为收到epoch-(e-1)的原因而进入时期e，它将立即在epoch开始时提出一个epoch-e的块

**选举投票：** 当节点处于本地时期e时，对于所收到的第一个有效提案（e，TX，h-1）(可能早于本地时期e），如果满足如下条件，则对提议进行投票：
  
- 节点观察到c使得H（c）= h_1，并观察到c的公证;
- 上面定义的父链c至少与节点在其本地时期e开始时观察到的最新的公证链一样新鲜。

**析构函数：** 定义Finalize(.)如下：
    定义Finalize（c）：= c [：l -1]; 其中chain [l]是链中的最后一个正常块。
    
换句话说，$c [：l] \preceq c$ 是链的最长前缀，以具有连续纪元号的两个块结束。

在任何时候，让chain成为节点到目前为止观察到的最新的公证链，如果Finalize（c）比当前输出日志长，则用Finalize（c）替换输出日志。

# 4. Basic Pala证明

**理想执行:** 后续我们忽略一些微不足道的破坏性执行，例如忠实节点的签名是伪造的或者是出现哈希碰撞。 为简单起见，在下面的所有定理和引理中，我们省略了“排除可忽略的概率” - 但是，读者应该记住，下面的所有定理和引理只适用于“理想执行”，其中忠实节点的签名不是伪造的，忠实节点视图的并集中不存在哈希冲突。

**术语** 我们定义如下有用的术语

- 我们说如果存在一些忠实的节点已经观察到链和它的公证，那么在某些执行中，链是一个忠实节点视图的公证链。 请注意，如果在某些执行中，链是忠实视图中的公证链，那么链的每个前缀也都是忠实视图中的公证链。
- $c \preceq c'$ 表示链c是链c'的前缀；按照惯例，$c \preceq c$

## 4.1 一致性

**引理1：** （每个时期e的唯一性）。 让c和c'在良好执行的忠实视图节点中是两个公证链，满足c [-1] .e = c'[ -  1] .e，则c = c'。
    
*证明* 假设两个不同的c和c'在它们的结束块中具有相同的时期e，并且两个链在忠实的视图中获得公证。 假设两个链之间没有哈希冲突，H（c）和H（c'）的不同签名总数必须至少为4n / 3。 但是，请记住，任何忠实的节点对一个纪元块的投票不超过一票，而作恶节点可以对H（c）和H（c'）投票。 因此，H（c）和H（c'）的不同签名的总数不能超过nH + 2nC = n + nC <4n / 3，其中nH和nC分别表示忠实和作恶节点的数量。 因此，我们得到了矛盾的结论。

**定理1** 定义c和c'在一个良好的执行中是忠实节点视图的两个公证链，则有$Finalize（c'）\preceq Finalize（c）$或$Finalize（c）\preceq Finalize（c'）$。

*证明* 出于矛盾的考虑，假设Finalize（c）和Finalize（c'）不是彼此的前缀; 令B0为它们的最后一个普通块，i0为索引，使得B0 = c [i0] = c'[i0]。

对于c和c'中的每一个，我们定义了待稳定块和稳定块的概念。 我们用c说明这些概念，并且以相同的方式定义与c'相关联的块。

- 待稳定块。 如果紧跟在B0之后的块c [i0 +1]是超时块，则链中的待稳定块B2是B0之后的第一个正常块。 否则，链中的待稳定块B2是c [i0 + 1]之后的第一个正常块; 这是很好的定义，因为Finalize删除链中的最后一个正常块。

- 稳定块。 链中的稳定块B1是紧接在待稳定块B2之前的块。

观察到B1和B2都在c中的B0之后。 我们以相同的方式为c'定义块B1'（稳定块）和B2'（待稳定块）。

我们接下来通过案例分析得出矛盾。 首先，观察如果c [i0 + 1]和c'[i0 + 1]都是正常块，则它们具有相同的纪元号; 但这与引理1相矛盾。因此，对于证明的其余部分，我们可以假设至少有一个c [i0 + 1]和c'[i0 + 1]是超时块。

接下来，定义e0 := B0.e，e := B2.e 和e':= B2'.e。 通过引理1，$ e \neq e' $;
不失一般性的假设e<e'。 我们分为两种情况：（i）e = e0 + 2，和（ii）e> e0 + 2。

（i）考虑e = e0 + 2的情况。必须是在链中，正常块B1 = c [i0 + 1]和B2 = c
[i0 + 2]分别具有时期数e0 + 1和e0 + 2。
    
    此外，由于B2是正常块，因此必须存在超过n/3个忠实节点的集合S，每个节点必须在其本地时期e0 + 2期间具有公证B2。特别地，S中的每个忠实节点都已经看到在本地时代e0 + 2期间链的前缀B1的公证。
    
    另一方面，我们可以推断出紧跟在c'中的B0之后的块Bx'= c'[i0 + 1]必须是具有一些纪元号e''的超时块，其中e''> = e0 + 3， 因为引理1。
    
    因为本地纪元数不能减少，对于S中的每个忠实节点，在纪元e'> e0 + 2的开始处，它必须已经看到链的前缀达到B1，其严格比直到B0的前缀更新鲜。 因此，可以得出少于2n / 3个节点可以投票给块Bx'。

（ii）考虑e> = e0 + 3的情况。在这种情况下，稳定块B1必须是具有时期编号e-1> = e0 + 2的超时块。

    由于B2是正常块，因此必须存在多于n / 3个忠实节点的子集S，每个节点在其本地时期e期间已经将链的前缀B1公证。
    
    观察到e <e'意味着c'必须具有从c [i0 + 1]到B2'的一些块，其时期号严格大于e。 因此，考虑c'中具有时期数e'的块Bx'，使得e''是大于e的最小时期。 通过选择Bx'，其前一个块最多具有时期数e; 但是，通过引理1，前一个块必须具有严格小于e的纪元号。
    
    因此，我们可以得出结论，在其本地时代e'> e的开头，S中的每个忠实节点必须看到链的前缀高达B1，这比c'不包括从Bx'开始的块更严格新鲜。因此，可以得出少于2n/3个节点可以投票给c'中的块Bx'。

这就完成了引理的证明。
    
## 4.2 活跃度

**事实1**
考虑一个好的执行，让[t0，t1]表示一段同步。如果某个忠实节点，在本地时期e时是在 $ r \in [t0 - \Delta, t1] $ 或是更早，那么到时间$r + \Delta $ 时，所有忠实节点都在时期e或是更高。

*证明：* 直接由“强同步周期”推得。

**引理2：** 考虑一个好的执行，让[t0，t1]表示一段同步。 假设在某个时间$ t \in（t0 + 2sec，t1）$，某个忠实节点进入其本地时期e并已过去最多2秒。那么，在时间t，没有忠实节点处于时期 e'>e ，除非在时刻t忠实节点视图存在e，e + 1，...，e' - 1的公证。

*证明：* 事实1，不可能在时间t某个忠实节点进入本地时期1分钟或更长时间。 因此，没有忠实的节点会在时间t + 1秒内为e'> e发送时钟（e'）。 现在，通过忠实的协议定义，忠实节点进入时代e'> e的唯一方法是接收epoch-（e' -  1）公证。 如果e'-1> e，要接收epoch-（e'-1）公证，至少一个忠实的节点必须首先输入epoch e' -  1并在该时期投票，因此必须存在于忠实的视图中 时代e' -  2的公证，等等。

**引理3（忠实的提议者可以成功提出）：** 考虑在[t0，t1]的同步时段良好执行，并且让t为属于同步时段的某个时间。如果一个忠实的提议者在$ t \in (t0+1sec, t1-1sec) $时首先进入时期e，那么它必须成功地提出一个epoch-e块;此外，在提出划一e块之前，忠实节点视图不能对e' > e进行任何公证。

*证明：* 通过引理2，当忠实的epoch-e提案者（表示为u）1秒进入本地时期e时，除非在忠实节点视图中存在epoch-e的公证，否则任何忠实的节点（包括u本身）都不能处于时代e'> e视图 —— 但是直到你提出一个epoch-e块才会发生这种情况。因此，如果时期e提议者在其深入本地时期1秒之前已经看到了一个epoch-（e-1）的公证链，那么它必须通过算法的定义成功地提出。否则，当它1sec进入本地时期e时，它将尝试在其视图中提出从最新的公证链延伸的块。这足以证明这个最新的公证链不包含来自时代e'> = e的任何块。显然，在u提出一个时代e块之前，没有一个时代e块可以在忠实节点视图中进行公证;通过引理2，在u制作一个时代提议epoch-e之前，没有忠实的节点可以处于本地时代e'>e（因此没有忠实的节点会投票给任何一个epoch-e'块)。因此，在u为e'> e提出一个划时代的提案之前，没有一个epoch-e'块可以在忠实的观点中进行公证。

**引理4(忠实提议获得公证)：**  在良好的执行中考虑表示为[t0，t1]的同步时段。 假设一个诚实节点在时间$ t \in（t0 + 1sec，t1-1sec）$ 提议一个链延伸的epoch-e的块B.那么，在时间t + 1sec，每个诚实节点将看到链+B的公证。

*证明：* 当一个诚实的提议者u在$ t \in（t0 + 1sec，t1-1sec）$ 提出一个块时，到时间$ t + \Delta$， 由于“强同步时间”假设，每个诚实节点都将收到所提议的块延伸的父链及其公证。由事实1，通过时间$ t + \Delta$，所有诚实节点将进入时代e或更高。注意，一个诚实的节点只能在进入其本地时期e的1sec时提出epoch-e块。通过引理2，到时间$ t + \Delta $没有诚实的节点在时代e'> e，除非在那时候在诚实节点视图存在一个epoch-e的公证 - 并且在后一种情况下，由于“强同步时期”假设和事实，诚实的节点将只投票给u提出的epoch-e块。

因此，此后我们可以假设对于每个节点节点i，在$ [t，t + \Delta] $中的某个时间点，i已经接收到所提出的块延伸的父链及其公证，此外i在本地时期e中。只要表明i会在发生这种情况时投票支持该提案就足够了（这适用于每个诚实的节点i）。为了证明这一点，证明诚实提议所依赖的父链表示的链至少与任何诚实节点在其本地时代e开始时的最新的公证链一样新鲜就足够了。现在，如果提案的父链是在时期e-1结束，那么由于引理3，声明显然成立。否则，假设父链在e'<e-1处结束。这意味着诚实的提议者u必须在它进入本地时代1秒时提出这个块。 这意味着诚实的节点在t-1sec+之后不能进入epoch e或更高。因此，如果某个忠实节点在其本地时代e开始时已经看到了一个e''> e'的公证链，那么通过“强同步时间”假设,忠实的提议者u，在它进入本地时代e的1秒内一定可以看到它(即在时间t）。 因此，u不能建议扩展时代e'<e''的父链。

**定理2（活力）：** 考虑一个好的执行，让[t0，t1]表示执行期间的同步周期。 假设epoch-e和epoch-（e + 1）都具有忠实的提议者，此后分别表示为u和v。此外，假设u在时间$ t \in（t0 + 1sec，t1-2sec）$进入时期 e。那么对于每个诚实节点i，其在时间t + 2sec的输出日志一定比在时间t的日志长，并且必须包含由u提出的块。

*证明：* 由于引理3和4，u在t+1sec内必须成功提出一个epoch-e块，所有诚实的节点都将看到一个epoch-e公证块。因此，v在t+1sec内进入时期e+1或是更高。根据引理2，v在时间t+1sec时不能进入高于e+1的时期。因此，当v在[t，t + 1sec]期间进入epoch-（e + 1）时，通过引理3，v必须成功提出一个epoch-（e + 1）块。不难看出，这个块必须从块epoch-e延申，无论v是在1秒之前提出进入本地时代e + 1，还是在1秒之后进入本地时代e + 1。

**推理1(在足够长的同步期间的活动).** 除了在执行选择中k概率可忽略不计之外, 必须是在[t0，t1]的任何同步期间，至少$ \omega(log k)$min 长，它必须是任何诚实节点，与t0时的输出日志相比较，其在时间t1输出日志包含一个或多个有忠实节点提议的块。

*证明：* 由于事实1和忠实协议的定义，如果一个忠实节点在时间$ t \in [t0，t1-3sec] $进入时期e，那么到时间t+1min+2sec,所有忠实节点必须已进入时期e + 1或更高。因此，如果[t0, t1]至少有$ \omega(log k) $min长，则必须存在至少$ \omega(log k) $min连续的时代(表示为集合E)，以便所有忠实节点在(t0 + 3sec, t1 - 3sec)内进入这些时代（E）。

# 5 双

