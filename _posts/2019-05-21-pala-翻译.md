---
layout: post
title: pala中文
tags: 
- 共识协议
- pala
categories: 区块链
---
* TOC
{:toc}

## 1.1 Pipelined-BFT范式的背景
经典型BFT协议使用两轮或多轮投票来确认每个块，例如在PBFT中，它们分别被称为“prepare”轮和“commit”轮。最近，加密货币社区出现了一个优雅的流水线理念，即，如果每个块需要两轮投票，为什么不在第二轮投票中捎带？这个想法在Buterin和Griffith [15]的优雅Casper-FFG作品中被隐含地描述，其形式为终极小工具“用于工作证明区块链。论坛和在线博客帖子[2,3]表明DPoS （即，EOS采用的共识协议，按市值排名前5的加密货币[1]）可能正在考虑采用类似的方法，尽管在撰写本文时尚未发布对DPoS协议和证据的正式描述。 Casper-FFG [15]和DPoS [2,3]的这种想法的实例都只实现了同步性能，即，即使网络能够更快地传送数据包，这些协议也只能以较慢的间隔确认块。 DPoS仅以固定间隔提出块[2,3]，而在Casper [15]中，块提议是进程是潜在的PoW区块链，因此块提议仅偶尔以随机间隔发生。

Abraham等人最近的优雅作品HotStuff。 [4]扩展了这种“流水线”方法，以提供可证明安全的BFT协议，容忍部分同步网络中的2/3损坏。在高层次上，PaLa依赖于与HotStuff非常相似的直觉（但我们给出了一些 - 在实现中可能有价值的更简单的想法表示）。在HotStuff中，活跃依赖于拥有一个旋转的提议者（即“支持民主的方法”），而在PaLa中，我们还展示了如何使用适合性能要求的场景的稳定性偏好的提议者轮换策略来实例化PaLa（参见章节 9关于具体的，现实世界的应用场景的更多讨论）。此外，我们提出了一种双流水线变体，它是对性能要求严格的场景所必需的流水线-BFT范例的进一步概括。此外，如上所述，我们提出了一种简单的方法来启用委员会切换（我们考虑的应用程序也需要这种方法）。

## 1.2 协议概述
我们在此提供PaLa共识协议的描述，重点是“随机”提议者选举政策和固定委员会。设d是同步期间网络延迟的约束。由于我们处于部分同步模型中，协议只需要在同步期间取得进展，但一致性/安全性应始终保持在任意网络分区之下。为了简化表示法，我们将使用别名第二个引用cd，别名分钟表示c^2d（即c秒）表示某些适当的常量c（在实际协议中c = 6）

每个节点保持一个从0开始的本地时期计数器e和当前的一个块链（b1, b2,...,bn）;每个块具有形式（e,TXs,h_1），使得时期数e严格增加，并且h_1是当前块之前的链的散列。我们说如果p包含来自链中每个块的 >= 2/3的有效签名，则p是链的公证。链的纪元号被定义为最后一个块的纪元号。该协议如下：
    
- **更新链**：每个节点都存储到目前为止所见的最新的公证链c。 当一个节点看到一个有效的链c'（上述形式）带有公证时，其时代号高于其当前链c的时期号（我们称c'比c更“更新”）c'替换当前链。
- **块提案**：在每个时期e中，通过将哈希函数（随机预言）应用于时期号而确定的随机节点被选为“提议者”。 提议者进行如下：
    - 如果提议者的链以一个时期块e-1结束，则提议者可以立即提出一个新块（e; TX; H（c））并将其多播，其中TX表示要确定的未完成事务。
    - 如果提议者的链具有早于e-1的时期，（如先前的提议者未能将其块包含在链中），则等待1秒（以便可能接收“更新鲜的”链），之后提出一个新的块（如前一种情况）。
- **公证**：在时期e，每当节点i从时期e的提议者接收块（e; TXs; h_1）时（1）它已经看到与h_1一致的公证链c-1，并且（2）c-1是 至少和时代e开始时的链条一样新鲜，并且（3）它之前没有为时期e签署过块，我签署了块并对签名进行了多播。
- **时代推进**：无论何时发生以下事件中的任何一个并且当前处于小于e的时期，节点i前进到时期e：（1）它看到用于纪元e-1的公证链，或者（2）它接收到>=2/3节点数个带签名的clock(e）消息。 如果自节点进入纪元e-1以来已经过了一分钟，它将组播clock(e）。

**蓝图**.上述协议称为基本PaLa，将在第3节中正式描述，并在第4节中证明是安全的。

然后，我们专注于描述PaLa的概括，称为双重流水线PaLa，面向高性能场景。 这个应用程序是由ThunderCore推动的，ThunderCore是一个区块链公司，旨在将以太坊转移到被称为“加速器”的专用基础设施节点（即提议者）加速的“快速路径”。 我们还描述了使用PaLa执行委员会重新配置的简单但非平凡的技术。

# 2.模型
## 2.1 部分同步网络建模
**背景:与GST建模部分同步.** 我们采用部分同步通信网络，我们的正式模型是Dwork，Lynch和Stockmyer [10]提出的“全球稳定时间（GST）”模型的扩展。 回想一下GST模型假设如下：

- 最终，在被称为GST的一些点，网络将稳定和诚实的消息将d的时间内交付。
- 部分同步协议提供参数d但协议不知道GST。

**长时间运行的部分同步建模.** 由Dwork等人提出的GST模型。 [10]更适合单发一致性协议。 相比之下，区块链协议是长期运行的，确认了不断增长的，线性排序的日志（例如，交易）。 因此，我们将GST模型扩展为适合这种长期运行的场景。

我们正式定义了一个称为同步周期的概念。 直观地，一段同步是当网络连接良好并且诚实节点或多或少同步时，它们可以彼此通信经历最大d延迟。 然而，有时，网络可能失去同步，例如，在重大中断或分区期间。 当发生这种网络分区时，部分同步协议应该保持一致性。 另一方面，只有在同步期间才需要活跃度。 一种部分同步协议知道参数d（即，协议能解密有d硬连线在它），但不知道当同步的周期会发生。

**定义1(同步周期)。** 修正一些协议执行。我们说周期[t0, t1]是同步期(w.r.t.执行)，当且仅当一个诚实节点在其本地时间t<=t1发送的每条消息在其本地时间max(t0, t +d)之前也会被任何其他诚实节点接收到。

我们注意到，在一些关于部分同步共识的现有工作中已经采用了“同步时期”这个术语（有时是非正式的）[4,5]。 上述定义1是我们对本文采用的这一概念的明确表述。

为了方便起见，在本文中，除非另有说明，否则我们假定节点总是通过向每个人多播消息来响应它看到的每条新消息—注意，所有消息都将在我们的协议中签名。这样，我们可以做出一个更强的同步假设:

**定义2(较强的同步周期概念)。** 我们说周期[t0, t1]是同步的周期(w.r.t.此执行)，当且仅当一个诚实节点在其本地时间t <= t1观察到的每条消息在其本地时间max(t0, t + d)之前也将被任何其他诚实节点观察到。

**备注1.** 在整篇论文中，我们可以假设节点允许有界时钟偏差，在这种情况下，诚实节点之间的最大时钟偏差被符号d吸收。

## 2.2 执行模型和假设
总共有n个节点编号为1,2，...，n，其中n是公知参数。 我们假设公钥基础结构（PKI）和第i个节点的公钥表示为pki，并且相应的密钥表示为ski。

**腐败模型。** 我们假设一个多项式有界的对手可以破坏少于n / 3个节点。 为简单起见，我们将首先在静态损坏模型下证明安全性，其中攻击者在开始执行之前做出腐败选择。 稍后在A.1节中，我们将解释如何将我们的安全保证扩展到自适应损坏，即，当攻击者在协议执行过程中自适应地破坏节点时。

在本文中，我们假设所有诚实节点在0时刻开始执行协议。

# 3.热身：基本的PaLa
## 3.1定义和符号
**单位时间的别名。** 为方便起见，我们使用术语一秒钟（或简称为秒）和一分钟（或简称为分钟）不通过挂钟测量时间，而是作为特定时间单位的别名（即输入到协议的参数）。 在整篇论文中，我们假设如下：
$$
1sec \geq 5\Delta \quad and   \quad 1min \geq6sec
$$

**有效块:** 现在块的形式为（e,TXs, h_1），即，我们不再需要块中的时间戳字段; 此外，现在每个块都带有一个时代号 $ e \in N $。 TXs和h_1的定义如前所述。

**区块链定义：** 一个有效的区块链，表示c，是一个有序的块序列。
因此，我们使用以下符号:
- c[i]表示链中第i个block，其中1 <= i <= |c|;为了方便起见，我们假设每个区块链c前面都有一个虚构的genesis块$c[0]:= ((0,1),\bot,\bot,0)$;
- c[: i]表示直到第i个块(含)的所有块;
- c[-i]是c[L -i + 1]的别名，其中L = |c|;和

**区块链的有效性。** 一个区块链当且仅当满足如下条件时是有效的：
1. 对于每$1 <= i <=|c|$， c[i].h_1 = H(c[: i - 1])。
2. 对于任何$1 <= i <j <= |c|$，它必须是c [i] .e <c [j] .e，即有效区块链中包含的纪元数必须严格增加（但可能 跳跃）。
    
    我们稍后将在基本PaLa方案的证明中使用以下术语: 如果c [i] .e = c [i-1] .e + 1，则c [i]被认为是正常块; 否则它被称为超时块。

**“更新鲜”的关系。** 我们说c比c'更新，如果c [-1] .e> c'[ -1] .e。 如果c [-1] .e = e，我们也说c链是历元e链。像以前一样，我们有时使用术语“块”作为以该块为结尾的链的(前缀)的别名。
**投票和公证。** 如果$\sum.verify(pki, H(c),\sigma)= 1$，则签名$\sigma$被认为是来自节点$i\in[n]$的有效投票，其中pki表示节点i的公钥和$\sum$表示正在使用的签名方案。